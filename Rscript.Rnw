% 
% PATH=/usr/local/texlive/2014/bin/x86_64-linux/:$PATH Rscript -e "library(knitr); knit('limmaanalysis.Rnw')"
% PATH=/usr/local/texlive/2014/bin/x86_64-linux/:$PATH pdflatex -shell-escape limmaanalysis.tex
% 
\documentclass{article}
\usepackage{multirow}
\usepackage[table,xcdraw]{xcolor}
\usepackage{xcolor}
\usepackage[utf8]{inputenc}
\usepackage{bashful}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage[group-separator={,}]{siunitx}
\usepackage{booktabs}
\usepackage{accsupp}                    % BeginAccSupp
\usepackage{ragged2e}
\usepackage{caption}                    %for placing the plots where I want
\usepackage{subcaption}
\usepackage[T1]{fontenc}
\usepackage{listings}                   % Required for customising code formatting
\usepackage{lscape}
\usepackage{longtable}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}


\title{\textbf{CIPK16 Transgenic Effect on Arabidopsis: Limma Expression Analysis} \\
  \large A gene involved in enhanced salt tolerance \\}
\author{Shani Amarasinghe}
\date{July 2015}

\begin{document}

\maketitle

\tableofcontents

\cleardoublepage

<<options, cache=TRUE, eval=FALSE, echo=TRUE>>=
library(knitr)
library(R.utils)      # gunzip()
library(reshape2)     # dcast(), melt()
library(data.table)   # fread(), rbindlist()
library(ggplot2)
library(scales)
library(dplyr)        # group_by()
library(edgeR)        # DGEList()
library(grid)         # unit()
library(genefilter)
library(xtable)       # xtable()
library(GenomicFeatures) #Read counting
library(limma)
library(taRifx)       #to fix a dataframe
@

% Redefine the style used by bashful for formatting bash scripts
\definecolor{rulecolour}{rgb}{0,0.9,0}
\definecolor{backcolour}{rgb}{0.7,0.7,0.7}
\definecolor{commentcolour}{rgb}{0.1,0.1,0.95}
\newcommand{\noncopytext}[1]{%
    \BeginAccSupp{method=escape,ActualText={}}%
    #1%
    \EndAccSupp{}%
}
\makeatletter
\lst@AddToHook{OnEmptyLine}{\addtocounter{lstnumber}{-1}} % Remove line number increment from listings
\def\BL@prefix{}                    % disable prefixing of commands with a percentage sign
\makeatother
% TODO change comment style with commentstyle
\lstdefinestyle{bashfulScript}{ %
    columns=fullflexible,
    commentstyle=\color{commentcolour},
    upquote=true,
    aboveskip=5pt,
    belowskip=10pt,
    basicstyle=\small\ttfamily,      % the size of the fonts that are used for the code
    numbers=left,                    % where to put the line-numbers
    numberstyle=\tiny\color{black!85}\noncopytext,  % the style that is used for the line-numbers
    stepnumber=1,                    % the step between two line-numbers. If it's 1, each line 
%                                    % will be numbered
    numbersep=13pt,                  % how far the line-numbers are from the code. Add framesep value to this
    numberblanklines=false,           % Don't number empty lines
    backgroundcolor=\color{black!15},  % choose the background color. You must add \usepackage{color}
    showspaces=false,                % show spaces adding particular underscores
    showstringspaces=false,          % underline spaces within strings
    showtabs=false,                  % show tabs within strings adding particular underscores
    xleftmargin=20pt,
    xrightmargin=10pt,
    framesep=5pt,
    framerule=3pt,
    frame=leftline,                  % adds a frame around the code
    rulecolor=\color{rulecolour},     % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
    tabsize=2,                       % sets default tabsize to 2 spaces
    breaklines=true,                 % sets automatic line breaking
    breakatwhitespace=true,          % sets if automatic breaks should only happen at whitespace
    breakindent=20pt,
    breakautoindent=true,
    prebreak=\small\symbol{134},    % Before breaking to a new line, add a backslash (line continuation character)
    literate=%{*}{{\textasteriskcentered}}{1}
             {~}{{\texttildelow}}{1} % reformat the high tilde to a normal tile which looks good for printing and is copy-and-pastable
             %{-}{{\textminus}}{1},
}
\lstdefinestyle{bashfulStdout}{ %
    numbers=none,
    backgroundcolor=\color{black!5},
    rulecolor=\color{white}
}
\lstset{morecomment=[l]{\#}}


\section{quality control}

To be completed...

\section{Genomic Alignment}

\justify
Quantification of expression from RNA-seq data can quickly and accurately be performed by alignment
to the reference genome, when the experiment is performed on an organism with a well annotated
genome like human, mouse or in our case Arabidopsis. A fundamental problem with aligning to the genome is the difference
between the genome and the transcriptome: In RNA-seq we are sequencing RNA molecules which
often differs from the corresponding transcribed region in the genome due to splicing or other factors
such as fusion transcripts (Figure 1).

\begin{figure*}[t]
\centering
\includegraphics[width=1.0\textwidth]{extra//626px-RNA-Seq-alignment.png}
\caption{The RNA-Seq Alignment between genome and transcriptome}
\end{figure*}

\subsection{Running STAR aligner}

\justify
To align their large (above 80 billon reads) ENCODE Transcriptome RNA-seq dataset, a team of researchers at Cold Spring Harbor Laboratory developed the Spliced Transcripts Alignment to a Reference (STAR) software based on a previously undescribed RNA-seq alignment algorithm that uses sequential maximum mappable seed search in uncompressed suffix arrays followed by seed clustering and stitching procedure.

\item \textbf{Very high mapping speed:}
on a modest 12-core cluster STAR maps 400 Million pairs per hour for human 2×100 Illumina reads (50 times more faster than TopHat).
\item \textbf{Accurate alignment of contiguous and spliced reads:}
in our tests on real and simulated data STAR showed better sensitivity and precision than TopHat.
Detection of polyA-tails, non-canonical splices and chimeric (fusion) junctions.
\item \textbf{Mapping reads of any length:}
STAR can efficiently map reads of any length generated by current or emerging sequencing platforms, starting from ~15 bases (small RNA) and up to full length transcripts several kilobases long.
\item \textbf{Thorough testing on large ENCODE datasets:}
STAR was used to map 64 Billion reads of long RNA-seq and 16 Billion reads of short RNA-seq, and will be used to map RNA-seq data in the next ENCODE phase.

STAR requires ~30GB of RAM for mapping to the human genome (could be reduced to 16GB in the “sparse” mode with some speed loss).

\begin{figure*}[t]
\centering
\includegraphics[width=1.0\textwidth]{extra//STAR.png}
\caption{Schematic representation of the Maximum Mappable Prefix search in the STAR algorithm for detecting \textbf{(a)} splice junctions, \textbf{(b)} mismatches and \textbf{(c)} tails}
\end{figure*}

\subsubsection{Step1: Creating the genome Index}
\bash[script]
#/usr/local/Programs/STAR/STAR-2.4.1c/STAR \
#--runThreadN 25 --runMode genomeGenerate \
#--genomeDir /mnt/bioinf-1/shani/Rnaseq/salt_Arabidopsis/Reference_files/Star_genome/ \
#--genomeFastaFiles /mnt/bioinf-1/shani/Rnaseq/salt_Arabidopsis/Reference_files/TAIR10_chr_all.fa 
#--sjdbGTFtagExonParentTranscript /mnt/bioinf-1/shani/Rnaseq/salt_Arabidopsis/Reference_files/gff/TAIR10_GFF3_genes.gff 
#--sjdbOverhang 100
\END

\subsubsection{Aligning: an example}
\bash{script}
#cd /Root/Sample_A17;\
#/usr/local/Programs/STAR/STAR-2.4.1c/STAR \
# --outWigType bedGraph \
# --outFilterIntronMotifs RemoveNoncanonical \
# --alignIntronMax 2000 --alignMatesGapMax 2000 --runThreadN 25 \
# --genomeDir /mnt/bioinf-1/shani/Rnaseq/salt_Arabidopsis/Reference_files/Star_genome \
# --readFilesCommand 'pigz -dcp2' \
# --outFilterMismatchNmax 0 --outFilterMultimapNmax 1 \
# --outSAMunmapped Within \
# --readFilesIn /mnt/bioinf-1/shani/Rnaseq/salt_Arabidopsis/raw_data/Root/Sample_A17/A17_CGATGT_L001_R1_001.fastq.gz \
# /mnt/bioinf-1/shani/Rnaseq/salt_Arabidopsis/raw_data/Root/Sample_A17/A17_CGATGT_L001_R2_001.fastq.gz \
# --outSAMtype BAM SortedByCoordinate --outFileNamePrefix A17_CGATGT_L001_ \
# --outSAMattrRGline ID:A17_CGATGT_L001 DS:"Root Null Control (0Mm)" LB:TruSeq_Stranded PL:Illumina SM:A25 \
# --outSAMstrandField intronMotif;
\END

\subsubsection{Creating symlinks to the BAM files}
\bash{script}
#time find ../Mapping/3Hr/ -name "*Aligned.sortedByCoord.out.bam" -print0 |\
#xargs -0 --max-args 6 --max-procs 16 -I '{}' ln -s '{}' ./
#indexing
#find ./ -name "*.bam" -print0   | \
#xargs -0 --max-args 10 --max-procs 100 -I '{}' \
#/usr/local/Programs/samtools/samtools-0.1.19/samtools index '{}'
\END

\sectioon{DE Analysis}

\subsection {Input processing}

\justify
Running this script from the beginning to end will result in limma analysis on the Arabidopsis CIPK16 proprietary data of ACPFG linked used in my PhD project names "Transcriptional Netowkrs associated with CIPK16,: A gene involved in enhanced salt tolerance". However, there are some prerequsists needed.

\subsubsection{Creating the metadata file}

<<metadata file creation, cache=TRUE, eval=FALSE, echo=TRUE>>=

#%%%% metadata files %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#input metadata for 3 hr time point
metadata.3                <- as.data.frame(read.table("BAMs/metadata.3Hrs.refined.txt", 
                           header=TRUE)) # removed are the strange root and shoot samples
# I have removed the bamfile A30, and A14 from the new refined metadata list because it has
#unusual level of CIPK16 in it.
metadata.3$Code           <- paste(metadata.3$Tissue, 
                           metadata.3$Treatment, metadata.3$Genotype, 
                           sep=".")
metadata.3$ExpGroup       <- paste(substr(metadata.3$Tissue, 1, 1), 
                           metadata.3$Genotype, 
                           substr(metadata.3$Treatment, 1, 1),
                           substr(metadata.3$Time, 1, 1), sep='-')
metadata.3$biolrep        <- rep(1:30, each=2)
#Input metadata for 51 hour time point
metadata.51               <- as.data.frame(read.table("BAMs/metadata.51Hrs.refined.txt", 
                           header=TRUE))
metadata.51$Code          <- paste(metadata.51$Tissue, 
                           metadata.51$Treatment, metadata.51$Genotype, 
                           sep=".")
metadata.51$ExpGroup      <- paste(substr(metadata.51$Tissue, 1, 1), 
                           metadata.51$Genotype, 
                           substr(metadata.51$Treatment, 1, 1),
                           substr(metadata.51$Time, 1, 2), sep='-')
metadata.51$biolrep       <- c(1:32)
#For the combined metadata file biolrep is defined as below
#because the 3hr samples have tech. reps but the 51 hour samples don't
metadata.combined           <- rbind(metadata.3[ ,c(-3)], metadata.51[, c(-8)])
rownames(metadata.combined) <- metadata.combined$CompleteFile

# Select a subset of the data for testing purposes
#metadata.combined <- metadata.combined[metadata.combined$Time == '51hr',]
@

\subsection {BAM file processing according to metadata file}

<<BAM file processing>>=
#extract out the names of the BAM files 
#to the bamFls variable (character variable)
bamFls.3                  <- list.files(path="BAMs/", 
                           pattern="bam$", full=TRUE)
bamFls.51                 <- list.files(path="BAMs/", 
                           pattern="bam$", full=TRUE)
#Getting an bamfile name list ordered according 
#to the order of metadata
bamFls.ordered.3          <- bamFls.3[match(metadata.3$Filename,
                           (sub("\\..*", "", basename(bamFls.3))))]
bamFls.ordered.51         <- bamFls.51[match(metadata.51$Filename,
                           (sub("\\..*", "", basename(bamFls.51))))]
#Assigning names to each data in bamFls_ordred using a 
#section of its basename
names(bamFls.ordered.3)   <- sub("\\..*", "", 
                           basename(bamFls.ordered.3))
names(bamFls.ordered.51)  <- sub("\\..*", "", 
                           basename(bamFls.ordered.51))

bamFls.combined           <- c(bamFls.ordered.3, bamFls.ordered.51)
@

\subsubsection {Counting reads}

<<Counting with featureCounts, cache=TRUE, eval=FALSE, echo=TRUE, dependson=c('input_processing')>>=
library(Rsubread) #can download from bioC

fc <- featureCounts(metadata.combined$CompleteFile, 
                    isPairedEnd         = TRUE, 
                    annot.ext           = "Reference_files/gtf/Arabidopsis_thaliana.TAIR10.29.gtf", #edited the gft file to match the bam files
                    isGTFAnnotationFile = TRUE,
                    GTF.featureType     = "exon",
                    GTF.attrType        = "gene_id", 
                    strandSpecific      = 2, #options are 0 unstranded, 1 forward, 2 reverse
                    nthreads            = 20
      )
fc.antisense <- featureCounts(metadata.combined$CompleteFile, 
                    isPairedEnd         = TRUE, 
                    annot.ext           = "Reference_files/gtf/Arabidopsis_thaliana.TAIR10.29.gtf", #edited the gft file to match the bam files
                    isGTFAnnotationFile = TRUE,
                    GTF.featureType     = "exon",
                    GTF.attrType        = "gene_id", 
                    strandSpecific      = 1, #options are 0 unstranded, 1 forward, 2 reverse
                    nthreads            = 20
      )
#Renaming the column names for the count matrix
colnames(fc$counts)    <- rownames(metadata.combined)
#colnames(fc.$counts) <- sub("^[^.]*..([^.]+.[^.]+).*", "\\1",colnames(fc$counts))
@

<<sanity checking.1_rawcounts>>=
#The "MappedReads.txt was acquired from the CountMappedReads.sh script in the working directory.
#However, please note that the bash script is not fully automated. I'm trying to get it fully automated soon.
#Meantime, I only have to change the folders of Bam files 
#and on the output remove unwanted sections from the BAM file names

#Make the counts statistics
plot.counts.stats <- function (fc, metadata, variab){
      stats                <- t(fc$stat[-c(1)])
      colnames(stats)      <- fc$stat$Status
      #stats.percentage    <- prop.table(as.matrix(stats), margin=1)*100
      #Can use the stats.percentage for below steps as well
      library("reshape2")
      m.stats              <- melt(stats)
      #m.stats             <- melt(stats.percentage) 
      m.stats$file         <- gsub("BAMs.(.*)_Aligned.*","\\1", rownames(stats))
      #m.stats$tissue      <- metadata$Tissue[match(m.stats$file,(sub("^([^-|_]+).*","\\1",metadata$Filename)))] 
      m.stats$tissue       <- metadata$Tissue[match(m.stats$file,(sub("(.*)_Aligned.*","\\1",metadata$Filename)))]
      #m.stats$exp_genotype<- paste( m.stats$file, metadata$Genotype[match(m.stats$file,(sub("^([^-|_]+).*","\\1",metadata$Filename)))], sep="_")
      m.stats$exp_genotype <- paste( m.stats$file, metadata$Genotype[match(m.stats$file,(sub("(.*)_Aligned.*","\\1",metadata$Filename)))], sep="_")
      m.stats$time         <- metadata$Time[match(m.stats$file,(sub("(.*)_Aligned.*","\\1",metadata$Filename)))]
      colnames(m.stats)    <- c("file_complete", "type", "count", "file", "tissue", "exp_genotype", "time")

      library(ggplot2)
      
      g.stats <- ggplot(m.stats,
                        aes(
                          x=exp_genotype,
                          y=count,
                          fill=type))+
                  geom_bar(
  					            stat='identity')+
					        scale_y_continuous(expand = c(0, 0)) +
					        facet_grid(.~time, scales='free_x', drop=TRUE)+
					        theme(
            						text = element_text(size=5), 
            						axis.text.x = element_text(
            							angle = 90, 
            							hjust = 0.95,
            							vjust = 0.2),
            						axis.title.y = element_text(vjust=1.25),
            						axis.title.x = element_text(vjust=-2),
            						plot.title   = element_text(vjust=2, hjust=1))+
        					ylab("Stats")+
        					xlab("File names")+
        					ggtitle(paste("Count matrix stats: ", variab, sep=''))
pdf(paste("Newest/",variab, "_count_matrix_stats.pdf", sep=""), width = 22, height=16, onefile=T, paper='A4r'); g.stats; dev.off() 
}

ReadCount = read.table("MappedReads.txt", header=F)
# a bit of polishing to remove total (not needed for plotting)
ReadCountSmall = data.frame(BAM = ReadCount$V1, Total = ReadCount$V2, Mapped = ReadCount$V3, Unmapped = ReadCount$V4)
# ggplot needs data in a specific layout
MeltedReadCount = melt(ReadCountSmall, id=c('BAM'))
names(MeltedReadCount) = c('BAM', 'Mapping', 'Reads')
# calculate the fraction of mapped reads
#%TODO: Don't think this is the correct way to fraction
#What I want is to get the fractions of mappedreads/total reads, counts/mapped reads
ReadsFraction = ddply(
   MeltedReadCount,
   .(BAM),
   summarise,
   Count.Fraction = Reads / sum(Reads)
)
# sort the data frame and add fraction to the data frame
to_graph = cbind(arrange(MeltedReadCount, BAM), fraction = ReadsFraction$Count.Fraction)
# Now all we have to do is plot the data
gp = ggplot(data=to_graph, aes(x=BAM, y=Reads, fill=Mapping)) +
     geom_bar(stat="identity",position = "dodge") +
     theme(axis.text.x = element_text(angle = 90, hjust = 0))
png("MappedReads.png")
gp
dev.off()

#Plotting the counts
par(las=2) # make label text perpendicular to axis
par(mar=c(14,8,4,2)) # increase y-axis margin.
barplot(fc$counts,names.arg=paste (sub("^([^\\.|_]+).*","\\1", colnames(fc$counts)), metadata.combined$ExpGroup[match((sub("^([^\\.|_]+).*","\\1",colnames(fc$counts))), (sub("^([^-|_]+).*","\\1",metadata.combined$Filename)))]), cex.names=0.6, main="Mapped raw read counts", ylab=NA, xlab=NA)
par(las=1)
mtext(side = 1, "Samples", line = 6)
mtext(side = 2, "Raw reads mapped", line = 6, las = 0)
@

\subsection {Creating the group variable}

<<groups, cache=TRUE, eval=FALSE, echo=TRUE, dependson=c('input_processing', 'Counting with featureCounts')>>=
#Creating the group object for 3Hr time point is the same as for summerizeoverlaps()
group.3 <- metadata.3$ExpGroup[
            match(colnames(fc$counts[,1:60]),
            metadata.3$Filename)]
#Creating group object for 51Hr time point is a little tricky. I match the string
#before a period (for the counts matrix) AND
#before a dash (for metadata$filename) to match the two variables
group.51 <- metadata.51$ExpGroup[
              match(
                #everything before the first period
                (sub("^([^.]+).*","\\1",colnames(fc$counts[,61:92]))), 
                #everything before the first dash
                (sub("^([^-]+).*","\\1", metadata.51$Filename)))] 

group.combined <- c(group.3, group.51)      
@

\section{Custom functions used in this analysis}

The stat settings

<<stats_settings>>=
# Different parameters needed for later analysis
min_fc                   <- 2
min_pvalue               <- 0.05
min_average_expression   <- 0
multiple_test_correction <- 'BH'
max_to_plot              <- 30
min_fc_to_plot           <- min_fc
normalization            <- "quantile"
@

Then a few customised functiones to plot the results

<<splitmeanE>>=
#Function splitmeanE  
    splitmeanE           <- function(df) {
                            s = split( df, df$SampleID) #splits vE.long according to sampleID
                            sapply( s, function(x) mean(x$Expression) ) #calculates mean expression levels
    }
@

<<expression plot>>=
expression_plot <- function(v, transcript, metadata, coef, reg) {
    vE.long               <- melt(v$E[transcript,, drop=FALSE], value.name='Expression')
    #Renaming the columns for easy reference later
    colnames(vE.long)     <- c(transcript, 'Code', 'Expression')
    vE.long               <- cbind(vE.long,metadata[match(vE.long$Code,rownames(metadata)),])
    #calling the function splitmean and storing results as a dataframe
    u                     <- as.data.frame(splitmeanE(vE.long))
    colnames(u)           <- c("avgExpr")
    #binding the two dataframes together based on the sampleID and row name of new dataframe
    vE.long               <- cbind(u,vE.long[match(row.names(u), vE.long$SampleID),])
    vE.long$SampleID <- factor(vE.long$SampleID)
    
    #Drawing the ggplot
    g <- ggplot(
        vE.long,
        aes(
            x    = Treatment,
            y    = avgExpr, # can use Expression as well
            fill = SampleID)
        ) +
         geom_dotplot(
            dotsize  = 1.5,
            binaxis  = 'y',
            stackdir = 'center'
        ) +
        theme(
            text                = element_text(size=16),
            panel.grid.major    = element_line(size=1),
            panel.grid.minor    = element_line(size=1.5),
            panel.margin        = unit(1.5, 'lines'),
            legend.position     = 'left',
            legend.direction    = 'vertical',
            axis.title.y        = element_text(vjust=1.25),
            axis.title.x        = element_blank(),
            plot.title          = element_text(vjust=2)
        ) +
        facet_grid(Tissue~Time~Genotype) +
        ggtitle(paste(transcript,unique(as.factor(vE.long$Time)),unique(as.factor(vE.long$Tissue)), sep=' ')) +
        
        stat_smooth(aes(group = 1), method = "lm", se = FALSE, color = "black", size = 0.5) +
        ylab('log2(CPM)')
        
    pdf(paste("Plots/", 
              unique(as.factor(vE.long$Time)),"+",
              unique(as.factor(vE.long$Tissue)),"+",
              coef, reg,
              transcript,".pdf"))
    print(g)
    dev.off()
    }
@

<<func_plot>>=
func_plot <- function(fit2, results, v, metadata){
  tt.all <- topTable(fit2, sort.by="none", number=Inf, adjust.method="none")
  
  for (coef in colnames(fit2)){
    tt <- subset(tt.all, tt.all$Gene_ID%in%(names(which(results[, coef]>0))))
    if (nrow(tt)>0){
      lapply(rownames(tt)[1], function(x) expression_plot(v, x, metadata, coef, "up"))}
    tt <- subset(tt.all, tt.all$Gene_ID%in%(names(which(results[, coef]<0))))
    if (nrow(tt)>0){
      lapply(rownames(tt)[1], function(x) expression_plot(v, x, metadata, coef, "down"))}
  }
  
}
@

<<Extracting custom contrasts>>=
extractContrasts <-  function (fit2, variab){
#Define your custom contrasts here
cont.matrix <- cbind(Transgeneeffect_Control = c(0,1,0,0), SvsCinNull=c(0,0,1,0),SvsCinTransgenic=c(0,0,1,1),TransgenedependentinSalt=c(0,0,0,1),Transgeneeffect_Salt=c(0,1,0,1))
#This contrast matrix is to extract the 
#1. effect of transgene on controls (Transgenic.C - Null.C)
#2. effect of salt response in nulls (Null.S - Null.C)
#3. effect of salt response int ransgenics (Transgenic.S - Transgenic.C)
#4. transgene dependent salt resposiveness ((Transgenic.S - Transgenic.C)-(Null.S - Null.C))
#5. effect of transgene on salt treated (Transgenic.S - Null.S)

fit.test  <- contrasts.fit(fit2, cont.matrix)
fit.test  <- eBayes(fit.test)
results.x <- decideTests(fit.test, method="separate", 
                                adjust.method = multiple_test_correction, 
                                p.value = min_pvalue, log2(min_fc))
print(summary(results.x))
tt        <- topTable(fit.test, sort.by="none", number=Inf, adjust.method="none")
#assign variab variable here to whatever you want
#extracting genes
for (coef in colnames(fit.test)){ 
      write.csv(subset(tt, tt$Gene_ID%in%(names(which(results.x[, coef]>0)))),
      file=paste(file.path(paste('./Results/classicinteractionmodel/',variab,'/toptables/', sep = '')), coef,'_up', '.csv')
      , row.names=TRUE)
      write.csv(subset(tt, tt$Gene_ID%in%(names(which(results.x[, coef]<0)))),
      file=paste(file.path(paste('./Results/classicinteractionmodel/',variab,'/toptables/', sep = '')), coef,'_down', '.csv')
      , row.names=TRUE)        
  }

vennDiagram(results.x[, c('TransgenedependentinSalt', 'SvsCinTransgenic', 'Transgeneeffect_Salt', 'Transgeneeffect_Control', 'SvsCinNull')], 
            include    = c("up","down"),
            counts.col = c("red","green"), 
            cex        = 1.5,
            circle.col = c("skyblue", "pink1", "mediumorchid", "yellow", "orange"),
            mar = c(1,1,1,1))
}
@

<<extracting results>>=
#To generalise the next steps we use general object names here onwards
extract_results_cim <- function(v, fit1, metadata, variab){
  dir.create(paste('./Toptables/',variab,'/', sep = ''), recursive=TRUE, showWarnings=FALSE)
  
  #Define your contrasts of interest
  cont.matrix <- cbind(
    Transgene_Effect_in_Controls      = c(0,1,0,0),
    Transgene_Effect_in_Salt          = c(0,1,0,1),
    Salt_Effect_in_Nulls              = c(0,0,1,0),
    Salt_Effect_in_Transgenics        = c(0,0,1,1),
    Transgene_Dependent_Salt_Response = c(0,0,0,1)
  )
  fit2 <- contrasts.fit(fit1, cont.matrix)
  fit2 <- eBayes(fit2)
  
  #extracting results
  # Note from decideTests manual:
  #   Although this function enables users to set p-value and lfc
  #   cutoffs simultaneously, this is not generally recommended. If the
  #   fold changes and p-values are not highly correlated, then the use
  #   of a fold change cutoff can increase the false discovery rate
  #   above the nominal level. Users wanting to use fold change
  #   thresholding are recommended to use ‘treat’ instead of ‘eBayes’,
  #   and to leave ‘lfc’ at the default value when using ‘decideTests’.
  results     <- decideTests(
                         fit2,
                         method        = "separate",
                         adjust.method = multiple_test_correction, 
                         p.value       = min_pvalue,
                         lfc           = log2(min_fc)
                       )
  print(summary(results))
  write.table( 
    summary(results), 
    file = paste("./summary.results.", variab, ".txt", sep=''),
    quote=FALSE,
    sep='\t',
    eol='\r',
    row.names = TRUE)
  
  venn <- vennDiagram(
    results,
    include    = c("up","down"),
    counts.col = c("red","green"), 
    cex        = c(1.5,1,0.7) * 0.6,
    circle.col = c("skyblue", "pink1", "mediumorchid", "yellow", "orange"),
    mar        = rep(3,4),
    main       = variab
  )
  pdf(paste('./Plots/',variab,"_venn_diagram.pdf", sep=''), onefile=T, paper='A4r'); print(venn); dev.off()
  
  for (coef in colnames(fit2)){
    tt     <- topTable(
      fit2,
      coef          = coef,
      adjust.method = multiple_test_correction,
      p.value       = min_pvalue,
      lfc           = log2(min_fc),
      number        = Inf
    )
    write.csv(
      tt,
      file      = paste(file.path(paste('./Toptables/',variab,'/', sep = '')), coef, '.csv'),
      row.names = TRUE
    )
  }
func_plot(fit2, results, v, metadata)  
}
@

<<extract_randomgenes>>=
plot.gene <- function(gene, v, metadata, supp_file){
  gene.v                <- subset(v$E,rownames(v$E)==gene)
  stats                 <- t(gene.v)
  m.stats               <- melt(stats)
  colnames(m.stats)     <- c("file_complete", "gene", "E")
  m.stats$file          <- gsub(".*BAMs/(.*).sortedByCoord.*","\\1", rownames(stats))
  m.stats$tissue        <- metadata$Tissue[match(m.stats$file, metadata$Filename)]
  m.stats$genotype      <- metadata$Genotype[match(m.stats$file, metadata$Filename)]
  m.stats$treatment     <- metadata$Treatment[match(m.stats$file, metadata$Filename)]
  m.stats$file_short    <- gsub("_.*","\\2", m.stats$file)
  m.stats$expgroup      <- paste(m.stats$file_short,( metadata$ExpGroup[match(m.stats$file, metadata$Filename)]), sep="-")
  #colnames(m.stats)     <- c("file_complete", "gene", "E", "file", "tissue", "genotype", "expgroup")
  m.stats$common        <- supp_file$common[match(m.stats$gene, supp_file$id)]
  #colnames(m.stats)     <- c("file_complete", "gene", "E", "file", "tissue", "genotype", "file_short", "expgroup", "common")

 #Drawing the ggplot
    g <- ggplot(
        m.stats,
        aes(
            x     = treatment,
            y     = E,
            fill  = treatment, 
            group = treatment
        )) +
        geom_dotplot(
            dotsize  = 0.8,
            binaxis  = 'y',
            stackdir = 'center'
        ) +
        stat_summary(
            fun.y=median, 
            fun.ymin=median, 
            fun.ymax=median, 
            geom="crossbar", 
            width=0.7
        )+
        theme(
            text                = element_text(size=20, face="bold"),
            panel.grid.major    = element_line(size=1),
            panel.grid.minor    = element_line(size=1.5),
            panel.margin        = unit(1.5, 'lines'),
            legend.position     = 'bottom',
            legend.direction    = 'horizontal',
            axis.title.y        = element_text(vjust=1.25),
            axis.title.x        = element_blank(),
            plot.title          = element_text(size=14, vjust=2),
            axis.text.x         = element_text(angle = 90, hjust = 1)
        ) +
        facet_grid(.~tissue~genotype, scales="free") +
        ggtitle(paste(gene, supp_file$common[match(gene, supp_file$id)], sep=": ")) +
        #stat_smooth(aes(group = 1), method = "lm", se = FALSE, color = "black", size = 0.5) +
        ylab('log2(CPM)')
        print(g)
}

library(reshape2)
library(ggplot2)
library(limma)

v                   <- v.root.3 #any v object you want
metadata            <- metadata.3  #any metadata object you want
gene_desc           <- read.csv("salt_genes/saltrelatedgenes_desc.csv", header=FALSE)
gene_desc           <- gene_desc[-c(1), c(2,6)]
colnames(gene_desc) <- c("id", "common")
avail_ids           <- as.vector(subset(rownames(v$E), rownames(v$E)%in%gene_desc$id))
pdf("Plots/saltrelatedgenes_shoots.pdf", height=10, width=32, onefile=T);
for (gene in avail_ids) {
  plot.gene(gene, v, metadata, gene_desc)
}; dev.off()
@

\section {Main analyses sections}

Complete run-through process for the steps for tissues separately to apply the classical interaction model(treatment-contrast parameterization).
Please note that a metadata file for the data (metadata.combined/metadata.3|51) has to be loaded and a count matrix (fc) should be available for data by now.

\subsection {Creatign Annotation file}

<<create_annotations, cache=TRUE, eval=FALSE, echo=TRUE>>=
#Reorder according to the ine_counts data
annot <- function (annot.file, fc){
  annotations           <- fread(annot.file, header=FALSE,
                         data.table=FALSE)
  colnames(annotations) <- c('Gene_ID', 'Annotation')
  #for count matrix got from featureCounts()
  annotations_sorted    <- annotations[match(
                           row.names(fc$counts), 
                           annotations$Gene_ID),]
  #sanity checking to see whether all the annotations are present
  table(row.names(fc$counts) %in% annotations$Gene_ID) 
  return(annotations_sorted)
}	
annotations_sorted <- annot("TAIR10_functional_descriptions_edited.txt", fc)
@

\subsection {Creating DGEList}

<<Creating the DGElist, cache=TRUE, eval=FALSE, echo=TRUE, dependson=c('summarizeOverlaps_function', 'create_annotations')>>=
library(edgeR)
library(DESeq)
dge.3    <- DGEList(
             counts = fc$counts[,1:60], 
             genes  = annotations_sorted,
             group  = metadata.combined[colnames(fc$counts)[1:60], 'ExpGroup']
          )
# Scale Normalisation
# Calculate sample-specific library-size normalisation factors
# This tries to account for differences in RNA composition of samples
# This might be particularly important when different tissues are being analysed
dge.3   <- calcNormFactors(dge.3)

#for the 51 hour data point
dge.51   <- DGEList(
             counts = fc$counts[, 61:92], 
             genes  = annotations_sorted,
             group  = metadata.combined[colnames(fc$counts)[61:92], 'ExpGroup']
          )  
dge.51   <- calcNormFactors(dge.51)		  
@

<<sanity checking.2_normalisedvalues>>=
#Plotting the library sizes
pdf("Plots/51.librarysizesfromdge.pdf", paper="A4r")
par(las=2) # make label text perpendicular to axis
par(mar=c(14,8,4,2)) # increase y-axis margin.
b.libs <- barplot(dge$samples$lib.size,names.arg=paste (sub("^BAMs.(.*)_Aligned.*","\\1", rownames(dge$samples)), dge$samples$group), cex.names=0.6, main="Library sizes from the DGElist object", ylab=NA, xlab=NA)
par(las=1)
mtext(side = 1, "Samples", line = 6)
mtext(side = 2, "Library size", line = 5, las = 0)
print(b.libs); dev.off()

#Plotting the normalised reads
 pdf("Plots/51.normalisedvaluesfromdge.pdf", paper="A4r")
par(las=2) # make label text perpendicular to axis
par(mar=c(14,8,4,2)) # increase y-axis margin.
b.norm <- barplot(cpm(dge$counts),names.arg=paste (sub("^BAMs.(.*)_Aligned.*","\\1", rownames(dge$samples)), dge$samples$group), cex.names=0.6, main="Normalised counts from the DGElist object", ylab=NA, xlab=NA)
par(las=1)
mtext(side = 1, "Samples", line = 6)
mtext(side = 2, "Normalised eads mapped", line = 5, las = 0)
print(b.norm); dev.off()

#Plotting the normalization factors
pdf("Plots/51.normfactorsfromdge.pdf", paper="A4r")
par(las=2) # make label text perpendicular to axis
par(mar=c(14,8,4,2)) # increase y-axis margin.
b.normfactors <- barplot(dge$samples$norm.factors,names.arg=paste (sub("^BAMs.(.*)_Aligned.*","\\1", rownames(dge$samples)), dge$samples$group), cex.names=0.6, main="Normalization factors for each sample from DGElist object", ylab=NA, xlab=NA)
par(las=1)
mtext(side = 1, "Samples", line = 6)
mtext(side = 2, "Normalisation factors", line = 3, las = 0)
print(b.normfactors); dev.off()
@

<<sanity checking.3_PCA plots>>=
draw_pca <- function(time, metadata,dge){
  cps.dge           <- t(t(dge$counts)* dge$samples$norm.factors)
  cps.dge           <- t(cps.dge) 
  pca.res           <- prcomp(cps.dge[, apply(cps.dge, 2, var) != 0],scale.=TRUE,retx=TRUE)
  expl.var          <- round(pca.res$sdev^2/sum(pca.res$sdev^2)*100)
  plot.pch          <- as.numeric(as.factor(paste((metadata$Tissue[match(rownames(cps.dge), rownames(metadata))]), (metadata$Treatment[match(rownames(cps.dge), rownames(metadata))]), sep="_")))
  plot.colrs        <- labels2colors(metadata$Genotype[match(rownames(cps.dge), rownames(metadata))])
  plot.labels       <- paste(metadata$ID, metadata$ExpGroup, sep="-")[match(rownames(cps.dge), rownames(metadata))]
  pdf(paste("PCAplots_", time, ".pdf", sep=""), paper="A4r", height = 2000, width= 2000, onefile=TRUE)
  plot(pca.res$x[, c(1,2)],
         col=plot.colrs, 
         pch=plot.pch,
         cex=1.1, 
         xlab=paste0("PC 1 (", expl.var[1], "%)"), 
         ylab=paste0("PC 2 (", expl.var[2], "%)"),
         main=paste("PC1 Vs PC2 for ", time, sep=""))
  legend("bottomleft", 
           legend = plot.labels,
           col=plot.colrs, 
           pch=plot.pch, 
           cex=0.5,
           ncol=6)
  plot(pca.res$x[, c(1,3)],
         col=plot.colrs, 
         pch=plot.pch,
         cex=1.1, 
         xlab=paste0("PC 1 (", expl.var[1], "%)"), 
         ylab=paste0("PC 3 (", expl.var[3], "%)"),
         main=paste("PC1 Vs PC3 for ", time, sep=""))
  legend("bottomleft", 
           legend = plot.labels,
           col=plot.colrs, 
           pch=plot.pch, 
           cex=0.5,
           ncol=6)
  plot(pca.res$x[, c(2,3)],
         col=plot.colrs, 
         pch=plot.pch,
         cex=1.1, 
         xlab=paste0("PC 2 (", expl.var[2], "%)"), 
         ylab=paste0("PC 3 (", expl.var[3], "%)"),
         main=paste("PC2 Vs PC3 for ", time, sep=""))
  legend("bottomleft", 
           legend = plot.labels,
           col=plot.colrs, 
           pch=plot.pch, 
           cex=0.5,
           ncol=6)
  plot(pca.res$x[, c(3,4)],
         col=plot.colrs, 
         pch=plot.pch,
         cex=1.1, 
         xlab=paste0("PC 3 (", expl.var[3], "%)"), 
         ylab=paste0("PC 4 (", expl.var[4], "%)"),
         main=paste("PC2 Vs PC3 for ", time, sep=""))
  legend("bottomleft", 
           legend = plot.labels,
           col=plot.colrs, 
           pch=plot.pch, 
           cex=0.5,
           ncol=6)
  barplot(summary(pca.res)$importance[2,]*100, angle = 45, main = paste("Proportions of variance of the PCA plot for " ,time, sep=""), xlab="Components", ylab="Proportion of variance", cex.names=0.7, cex.axis=0.3)
  print(summary(pca.res)$importance)
  dev.off()
}

time <- "51Hrs"
draw_pca(time, metadata.combined, dge.51)
@

<<Nonspecific_filtering, cache=TRUE, echo=TRUE, eval=FALSE, dependson=c('summarizeOverlaps_function', 'Creating the DGElist')>>=
nsfiltering <- function(dge){
cps.dge         <- cpm(dge)
###########################

##Filter 1: filter the genes that have 10 counts or less across all samples
expressed_with_at_least_11_counts_in_all_samples <- rowSums(cps.dge)>= 11

###########################
#Filter 2: filter the genes that are expressed in at least 4 samples (because I have 4 replicates per experimental group)
require("genefilter")
expressed_in_at_least_4_samples <- genefilter(cps.dge, filterfun(kOverA(k=4,A=0))) ### k must exceed A (i.e. cpm > 0)

###########################
##Cat the filters
pass.all.filters                  <- rep(TRUE, nrow(cps.dge))
pass.all.filters                  <- pass.all.filters & expressed_with_at_least_11_counts_in_all_samples
pass.all.filters                  <- pass.all.filters & expressed_in_at_least_4_samples
print (table(pass.all.filters))

############################
#retain the filtered out genes
#dge.filtered.out                  <- dge[!pass.all.filters,]
#apply the filters
dge                               <- dge[pass.all.filters,] 

return (dge)}
@

\subsubsection{3 hour time point root samples}

<<3hr_dge>>=
dge.3 <- nsfiltering(dge.3)
@

<<3hr_Root>>=
#Design matrix
tissue <- 'Root'
time   <- '3hr'
design.root.3    <-  model.matrix(
                      ~Genotype+Treatment+Genotype:Treatment,
                      metadata.combined[metadata.combined$Time == time & metadata.combined$Tissue == tissue,]
                     )
#Voom transformation
v.root.3         <- voom(
                      dge.3[,rownames(metadata.combined)[metadata.combined$Time == time & metadata.combined$Tissue == tissue]],
                      design.root.3,plot = TRUE, 
                      normalize          = normalization
                    )
corfit           <- duplicateCorrelation(
                      v.root.3,
                      design.root.3, 
                      block = metadata.combined$biolrep[metadata.combined$Time == time & metadata.combined$Tissue == tissue]
                    )
v2.root.3        <- voom(
                      dge.3[,rownames(metadata.combined)[metadata.combined$Time == time & metadata.combined$Tissue == tissue]],
                      design.root.3,
                      plot        = TRUE, 
                      block       = metadata.combined$biolrepbiolrep[metadata.combined$Time == time & metadata.combined$Tissue == tissue], 
                      correlation = corfit$consensus
                    )
#Fitting linear model
fit1.root.3        <- lmFit(
                      v2.root.3,
                      design.root.3, 
                      block = metadata.combined$biolrepbiolrep[metadata.combined$Time == time & metadata.combined$Tissue == tissue],
                      cor   = corfit$consensus
                    )
variab            <- 'root.3'
extract_results_cim(v2.root.3, fit1.root.3, metadata.combined, variab)
@

\subsubsection {3 hour time point shoot samples}

<<3hr_Shoot>>=
#design matrix
tissue <- 'Shoot'
time <- '3hr'
design.shoot.3    <-  model.matrix(
                      ~Genotype+Treatment+Genotype:Treatment,
                      metadata.combined[metadata.combined$Time == time & metadata.combined$Tissue == tissue,]
                     )
#Voom transformation
v.shoot.3         <- voom(
                      dge.3[,rownames(metadata.combined)[metadata.combined$Time == time & metadata.combined$Tissue == tissue]],
                      design.shoot.3,
                      plot = FALSE, 
                      normalize          = normalization
                    )
corfit           <- duplicateCorrelation(
                      v.shoot.3,
                      design.shoot.3, 
                      block = metadata.combined$biolrep[metadata.combined$Time == time & metadata.combined$Tissue == tissue]
                    )
v2.shoot.3        <- voom(
                      dge.3[,rownames(metadata.combined)[metadata.combined$Time == time & metadata.combined$Tissue == tissue]],
                      design.shoot.3,
                      plot        = FALSE, 
                      block       = metadata.combined$biolrepbiolrep[metadata.combined$Time == time & metadata.combined$Tissue == tissue], 
                      correlation = corfit$consensus
                    )
#Fitting linear model
fit1.shoot.3       <- lmFit(
                      v2.shoot.3,
                      design.shoot.3, 
                      block = metadata.combined$biolrepbiolrep[metadata.combined$Time == time & metadata.combined$Tissue == tissue],
                      cor   = corfit$consensus
                    )
variab            <- 'shoot.3'
extract_results_cim(v2.shoot.3, fit1.shoot.3, metadata.combined, variab)
@

\subsubsection {51 hour time point root samples}

<<51hr_dge>>=
dge.51 <- nsfiltering(dge.51)
@

<<51hr_Root>>=
#Design matrix
tissue <- 'Root'
time <- '51hr'
design.root.51    <-  model.matrix(
                      ~Genotype+Treatment+Genotype:Treatment,
                      metadata.combined[metadata.combined$Time == time & metadata.combined$Tissue == tissue,]
                     )
#Voom transformation
v.root.51         <- voom(
                      dge.51[, rownames(metadata.combined)[metadata.combined$Time == time & metadata.combined$Tissue == tissue]],
                      design.root.51,
                      plot      = TRUE, 
                      normalize = normalization
                    )
corfit           <- duplicateCorrelation(
                      v.root.51,
                      design.root.51, 
                      block = metadata.combined$biolrep[metadata.combined$Time == time & metadata.combined$Tissue == tissue]
                    )
v2.root.51        <- voom(
                      dge.51[, rownames(metadata.combined)[metadata.combined$Time == time & metadata.combined$Tissue == tissue]],
                      design.root.51,
                      plot        = TRUE, 
                      block       = metadata.combined$biolrep[metadata.combined$Time == time & metadata.combined$Tissue == tissue],
                      correlation = corfit$consensus
                    )
#Fitting linear model
fit1.root.51       <- lmFit(
                      v2.root.51,
                      design.root.51, 
                      block = metadata.combined$biolrep[metadata.combined$Time == time & metadata.combined$Tissue == tissue],
                      cor   = corfit$consensus
                    )
variab            <- 'root.51'
extract_results_cim(v2.root.51, fit1.root.51, metadata.51, variab)
@

\subsubsection {51 hour time point shoot samples}

<<51hr_Shoot>>=
tissue <- 'Shoot'
time <- '51hr'
design.shoot.51    <-  model.matrix(
                      ~Genotype+Treatment+Genotype:Treatment,
                      metadata.combined[metadata.combined$Time == time & metadata.combined$Tissue == tissue,]
                     )
#Voom transformation
v.shoot.51         <- voom(
                      dge.51[, rownames(metadata.combined)[metadata.combined$Time == time & metadata.combined$Tissue == tissue]],
                      design.shoot.51,plot = TRUE, 
                      normalize          = normalization
                    )
corfit           <- duplicateCorrelation(
                      v.shoot.51,
                      design.shoot.51, 
                      block = metadata.combined$biolrep[metadata.combined$Time == time & metadata.combined$Tissue == tissue]
                    )
v2.shoot.51        <- voom(
                      dge.51[, rownames(metadata.combined)[metadata.combined$Time == time & metadata.combined$Tissue == tissue]],
                      design.shoot.51,
                      plot        = TRUE, 
                      block       = metadata.combined$biolrep[metadata.combined$Time == time & metadata.combined$Tissue == tissue],
                      correlation = corfit$consensus
                    )
#Fitting linear model
fit1.shoot.51      <- lmFit(
                      v2.shoot.51,
                      design.shoot.51, 
                      block = metadata.combined$biolrep[metadata.combined$Time == time & metadata.combined$Tissue == tissue],
                      cor   = corfit$consensus
                    )
variab            <- 'shoot.51'
extract_results_cim(v2.shoot.51, fit1.shoot.51, metadata.51, variab)
@
\justify
To create generate the antisense results, I renamed the variable (variad) by adding a ".antisense" to the end. "e.g. shoot.51.antisense"

<<extracting_unique>>=
#This was needed for the 51 time point data as there were no transgene dependent salt responsive genes in its contrasts
extract.uniq.51 <- function(fit1, metadata, variab, variab2){
cont.matrix <- cbind(
    Transgene_Effect_in_Controls      = c(0,1,0,0),
    Transgene_Effect_in_Salt          = c(0,1,0,1),
    Salt_Effect_in_Nulls              = c(0,0,1,0),
    Salt_Effect_in_Transgenics        = c(0,0,1,1),
    Transgene_Dependent_Salt_Response = c(0,0,0,1)
  )
  fit2 <- contrasts.fit(fit1, cont.matrix)
  fit2 <- eBayes(fit2)
tt.salt.tr <- topTable(
      fit2,
      coef          = "Salt_Effect_in_Transgenics",
      adjust.method = multiple_test_correction,
      p.value       = min_pvalue,
      lfc           = log2(min_fc),
      number        = Inf
    )
tt.salt.null <- topTable(
      fit2,
      coef          = "Salt_Effect_in_Nulls",
      adjust.method = multiple_test_correction,
      p.value       = min_pvalue,
      lfc           = log2(min_fc),
      number        = Inf
    )
diff <- subset(tt.salt.tr, !(tt.salt.tr$Gene_ID%in%tt.salt.null$Gene_ID))
write.csv(
      diff,
      file      = paste(file.path(paste('./Toptables/unique_to_salt_effect_in_transgenics_',variab, sep = '')),'.csv'),
      row.names = TRUE
    )
common_3_51 <- subset(diff, diff$Gene_ID%in%(paste("transgenedep.sense.", variab2, "$Gene_ID", sep="")))
write.csv(
      common_3_51,
      file      = paste(file.path(paste('./Toptables/common_to_salt_effect_in_transgenics_in3and51_root',sep = '')),'.csv'),
      row.names = TRUE
    )
}
extract.uniq.51(fit1.root.51, metadata.51, "root.51", "root.3")                                       
extract.uniq.51(fit1.shoot.51, metadata.51, "shoot.51", "shoot.3") 
@

<<heatmaps>>=
library(ggplot2)
library(ggthemes)
library(viridis)
library(reshape2)
library(limma)

module_of_interest <- read.csv("wgcna/root/module_root_yellow.txt", header=FALSE)
test            <- subset(v2.root.3$E, rownames(v2.root.3$E)%in%module_of_interest$V1)
#colnames(test) <- gsub("(^BAMs/)(.*)(.sorted.*$)" , "\\2" , colnames(test))
#kmeans clustering for visualisation purposes
test.k          <- kmeans(test, 4, iter.max=100, nstart=1, algorithm="Lloyd", trace=FALSE)
test2           <- cbind(test, test.k$cluster)
colnames(test2) <- c(colnames(test), "k_cluster")
o               <- order(test2[ ,31])
test2           <- test2[, -31]
test            <- test2[o,]
test.m          <- melt(t(test))
colnames(test.m) <- c("file", "gene", "E")
test.m$expgroup <- metadata.combined$ExpGroup[match(test.m$file, metadata.combined$CompleteFile)]

gg <- ggplot(
        test.m, 
      		aes(
    				x = file, 
    				y = gene, 
    				)
    	    ) +
    	    geom_tile(
    			  aes(
             fill   = E,
             ),
            size = 1
          ) +
          geom_text(
            aes(
              label = round(E, 2)),
              size  = 0.02
          )+
          scale_fill_gradient(
            low   = 'white', 
            high  = 'steelblue',
            guide = FALSE
          ) + 
          theme(
            strip.text          = element_text(size=5, face = "bold"), #base_size didin't work
            plot.title          = element_text(size = 5, vjust=1, hjust=1, face = "bold"),
            axis.text.y         = element_text(size=0.5, face="italic"),
            axis.text.x         = element_text(angle = 90, hjust = 1, size=5)
          ) +
    	    scale_x_discrete(name="",expand = c(0, 0)) +
          scale_y_discrete(name="",expand = c(0, 0)) +
          facet_grid(~expgroup, scales = "free", space = "free")

pdf ("Plots/3hr_root_module_yellow.pdf"); print(gg); dev.off()
@

/section {WGCNA Analysis}

<<WGCNA prerequisits,cache=TRUE, eval=FALSE, echo=TRUE >>=
require("WGCNA")
require("flashClust") #require for somke functions within WGCNA
require("gplots") #for heatmap.2 function
allowWGCNAThreads() #to allow multithreading in WGCNA
load("/mnt/bioinf-4/shani/Arabidopsis_R_session/DE_All.RData")

location      <- "/mnt/bioinf-4/shani/Arabidopsis_R_session/wgcna/"

tissue        <- "root" # options are root or shoot
common_3_51   <- intersect(rownames(v.root.3$E), rownames(v.root.51$E))
r3            <- subset(v.root.3$E, rownames(v.root.3$E)%in%common_3_51)
r51           <- subset(v.root.51$E, rownames(v.root.51$E)%in%common_3_51)
r3_51         <- cbind (r3, r51)
@

<<preprocessing>>=
exprDat   <- t(r3_51) #options are r3_51, s3_51
GeneNames <- rownames(r3_51)


> str(setdiff(rownames(v.root.3), rownames(v.root.51)))
 chr [1:845] "AT1G01046" "AT1G01183" "AT1G01453" "AT1G02065" ...
> str(setdiff(rownames(v.root.51), rownames(v.root.3)))
 chr [1:31] "AT1G03790" "AT1G04445" "AT1G11850" "AT1G50550" ...
> str(intersect(rownames(v.root.3), rownames(v.root.51)))
 chr [1:21129] "AT1G01010" "AT1G01020" "AT1G01030" "AT1G01040" ...

#editing the rownames of the exprDat
#rownames(exprDat)  <- paste(metadata[rownames(exprDat), "ID"], metadata[rownames(exprDat), "ExpGroup"], sep="-")
#order the exprDat
#exprDat            <- exprDat[order(sub('.*\\B','',row.names(exprDat))),]
@

<<filter samples:optional>>=
#Check  for sample outliers using a simple hclust
sampleTree      <- hclust(dist(exprDat), , method = "average");
pdf(paste(location, tissue, "/sampletree_", tissue, ".pdf", sep=""))
par(cex = 0.6); par(mar = c(0,4,2,0))
plot(sampleTree, main = paste("Sample clustering to detect outliers in ", tissue, sep=""), sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
dev.off()
@

<<sft, cache=TRUE, eval=FALSE, echo=TRUE, dependson=c('Exporting data')>>=
#Choosing a soft-threshold to fit a scale-free topology to the network
powers <- c(c(1:10), seq(from = 12, to=20, by=2))
sft <- pickSoftThreshold(exprDat, powerVector = powers, verbose = 5) # For the root sample
# Plot the results
#sizeGrWindow(19,10);
# Scale-free topology fit index as a function of the soft-thresholding power
pdf(paste(location,"/", tissue, "/softpower_", tissue, ".pdf", sep=""),onefile=TRUE, paper="A4r");
par(mfrow=c(1,2)); cex1=0.6;
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], xlab="Soft Threshold (power)", ylab="Scale free Topology Model Fit, signed R^2", type="n", main=paste("Scale independence of ",tissue, sep=""))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], labels=powers, cex=cex1, col="red");
# Green line corresponds to using an R^2 cut-off
abline(h=0.80, col="green")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5], xlab="Soft Threshold (power)", ylab="Mean Connectivity", type="n", main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1, col="red");
abline(h=0, col="green")
dev.off()
@

<<softpower,cache=TRUE, eval=FALSE, echo=TRUE, dependson=c('sft') >>=
#Assigning the softpower threshold to a variable to use in the future steps      
softPower <- 9  #for root
softPower <- 7 #for shoot
@

<<scalefreeplot, cache=TRUE, eval=FALSE, echo=TRUE, dependson=c('sft', 'softpower')>>=
#Plotting the scale free plot
Connectivity <- softConnectivity(exprDat,power=softPower)-1
pdf(paste(location, tissue, "/softthresh", tissue, ".pdf", sep=""),onefile=TRUE, paper="A4r");
par(mfrow=c(1,1))
scaleFreePlot(Connectivity, main=paste("soft threshold for" , tissue, "power=", softPower, sep=" "), truncated=F)
dev.off()
@

<<generate adj and TOM, cache=TRUE, eval=FALSE, echo=TRUE, dependson=c('sft')>>=
#Generating adjacency and TOM similarity matrices based on the selected softpower
#calculate the adjacency matrix
adj     <- adjacency(exprDat,type = "signed", power = softPower);
#turn adjacency matrix into topological overlap to minimize the effects of noise and spurious associations
TOM     <- TOMsimilarityFromExpr(exprDat, networkType = "signed", TOMType = "unsigned", power = softPower, corType="bicor", pearsonFallback = "individual", maxPOutliers = 0.05);

colnames(TOM) = rownames(TOM) = GeneNames 
dissTOM <- 1-TOM
@

<<clustering, cache=TRUE, eval=FALSE, echo=TRUE, dependson=c('sft, generate adj and TOM')>>=
#hierarchical clustering of the genes based on the TOM dissimilarity measure
library("flashClust")
geneTree <- flashClust(as.dist(dissTOM),method="average");
#plot the resulting clustering tree (dendrogram)
pdf(paste(location, tissue, "/genetree_" , tissue, ".pdf", sep=""),onefile=TRUE, paper="A4r");
plot(geneTree, xlab="", sub="",cex=0.3); 
dev.off()
@

<<blockwisemoduledetection>>=
#bwnet <- blockwiseModules(exprDat, corType="bicor", maxBlockSize=2000, networkType="signed", power =10, minModuleSize=20, mergeCutHeight=0.988, deepSplit = 2, pamRespectsDendro = FALSE)
@

<<modules, cache=TRUE, eval=FALSE, echo=TRUE, dependson=c('generate adj and TOM', 'clustering')>>=
# Set the minimum module size
minModuleSize <- 20;

# Module identification using dynamic tree cut
dynamicMods <- cutreeDynamic(dendro = geneTree, distM = dissTOM, method="hybrid", deepSplit = 2, pamRespectsDendro = FALSE, minClusterSize = minModuleSize, verbose =3);
#for sofPower8 for root samples; 
#..cutHeight not given, setting it to 0.981  ===>  99% of the (truncated) height range in dendro

#the following command gives the module labels and the size of each module. Lable 0 is reserved for unassigned genes
table(dynamicMods)
#Plot the module assignment under the dendrogram; note: The grey color is reserved for unassigned genes
dynamicColors <- labels2colors(dynamicMods)
table(dynamicColors)
pdf(paste(location, tissue, "/genetreeanddynamiccolcors_", tissue,".pdf", sep=""),onefile=TRUE, paper="A4r");
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = "Gene dendrogram and module colors");
dev.off()

#Module significance
#GS1 <- as.numeric(cor(Traits,exprDat.3, use="p"))
#GeneSignificance1 = abs(GS1)
#ModuleSignificance <- tapply (GeneSignificance1, dynamicColors, mean, na.rm =  TRUE) 
#sizeGrWindow(8,7)
#par(mfrow = c(1,1))
#par(mar=c(7,8,4,2))
#par(las=2)
#plotModuleSignificance(GeneSignificance1,dynamicColors)

#discard the unassigned genes, and focus on the rest
restGenes <- (dynamicColors != "grey")
diss1     <- 1-TOMsimilarityFromExpr(exprDat[,restGenes], power = softPower)
colnames(diss1) = rownames(diss1) = GeneNames[restGenes]
hier1 <- flashClust(as.dist(diss1), method="average" )
pdf(paste(location, tissue, "/genetreeanddynamiccolcors_2_", tissue, ".pdf", sep=""),onefile=TRUE, paper="A4r");
plotDendroAndColors(hier1, dynamicColors[restGenes], "Dynamic Tree Cut", dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = "Gene dendrogram and module colors");
dev.off()

#without removing grey
#diss1     <- 1-TOMsimilarityFromExpr(exprDat, power = softPower)
#colnames(diss1) = rownames(diss1) = GeneNames

#set the diagonal of the dissimilarity to NA 
diag(diss1) <- NA;

#Viewing the MDS plot
#cmd1 <- cmdscale(as.dist(diss1),2)
#par(mfrow=c(1,1))
#plot(cmd1, col=as.character(dynamicColors[restGenes]),  main="MDS plot",xlab="Scaling Dimension 1",ylab="Scaling Dimension 2")

#Visualize the TOM plot. Raise the dissimilarity matrix to the power of 4 to bring out the module structure
#sizeGrWindow(7,7)
#TP   		<- TOMplot(diss1, hier1, as.character(dynamicColors[restGenes]))
#pdf(paste(location, tissue, "/TOMplot", tissue ,".pdf", sep=""),onefile=TRUE, paper="A4");
#print(TP)
#dev.off()

#Extract modules
module_colors <- setdiff(unique(dynamicColors), "grey")
for (color in module_colors){
    module <- GeneNames[which(dynamicColors==color)]
    write.table(module, paste(location,tissue, "/module_",tissue, "_", color, ".txt",sep=""), sep="\t", row.names=FALSE, col.names=FALSE,quote=FALSE)
}

#Look at expression patterns of these genes, as they are clustered
module.order <- unlist(tapply(1:ncol(exprDat),as.factor(dynamicColors),I))
m 			 <- t(t(exprDat[,module.order])/apply(exprDat[,module.order],2,max))
pdf(paste(location, tissue, "/heatmap_modules_",tissue,".pdf", sep=""),onefile=T, paper="A4r", width = 45, height = 45)
par(mfrow=c(1,1)); par(mar=c(10,8,4,12))
heatmap(t(m),zlim=c(0,1),col=heat.colors(256),Rowv=NA,Colv=NA,labRow=NA,cellheight=9.4, scale="none",RowSideColors=dynamicColors[module.order])
dev.off()
#We can now look at the module gene listings and try to interpret their functions .. for instance using http://amigo.geneontology.org/rte

#Finding genes with high intramodular connectivity in modules
for (mm in colnames(datKME)){
  FilterGenes_wgcna <- abs(datKME[mm])>.9
  hubgenes          <- dimnames(data.frame(exprDat))[[2]][FilterGenes_wgcna]
  write.table(hubgenes, paste("wgcna/", tissue, "/", sub("MM\\.(.*)","\\1", mm), "_hubgenes.tab",sep=""),sep="\t", row.names=FALSE, col.names=FALSE,quote=FALSE)
  descr <- subset(annotations_sorted, annotations_sorted$Gene_ID%in%hubgenes)
  write.table(descr, paste("wgcna/", tissue, "/", sub("MM\\.(.*)","\\1", mm), "_hubgenes_annot.tab",sep=""),sep="\t", row.names=FALSE, col.names=FALSE,quote=FALSE)
}
@

<<eigen genes, cache=TRUE, eval=FALSE, echo=TRUE, dependson=c('Exporting data')>>=
#Quantify module similarity by eigengene correlation. Eigengenes: Module representatives
MEList <- moduleEigengenes(exprDat, colors = dynamicColors)
MEs <- MEList$eigengenes

#How related at the modules? summerising each module by its eigengenes
signif(cor(MEs, use="p"),2)
pdf(paste(location, tissue, "/eigengenerelatedness_" ,tissue, ".pdf", sep=""),width = 45, height = 70)
plotEigengeneNetworks(MEs, "", marDendro = c(1,4,1,2), marHeatmap = c(5,4,1,2)); dev.off()
#pairwise scatterlpot of module eigengenes
#sizeGrWindow(8,9)
pdf(paste(location, tissue, "/moduleeigengenes_" ,tissue, ".pdf",sep=""), height=70, width=55)
plotMEpairs(MEs)
dev.off()

#Displaying module heatmaps and eigengenes to see the relationship between eachother
pdf(paste(location, tissue, "/modules_" ,tissue, ".pdf", sep=""), onefile=T, height = 12, width = 30)
  for (whichmodule in unique(dynamicColors)){
    whichmodule <- whichmodule
    ME<- MEs[, paste("ME", whichmodule, sep='')]
    #sizeGrWindow(8,7);
      par(mfrow=c(2,1), mar=c(0.3,15,10,5))
      plotMat(t(scale(exprDat[, dynamicColors==whichmodule]) ), nrgcols=30, rcols=whichmodule)
      title(whichmodule, cex.main = 2.9, line = 2)
      par(mar=c(20,10,0.5,2)); par(las=2)
      barplot(ME, col=whichmodule, main='', offset = 0, width=1.8, space=0.1, cex.main=2, cex.axis = 1, cex.lab = 2, cex.names = 2, mgp=c(5,1,.5), ylab="Eigengene expression", axisnames=T, names.arg = c(rep("R-Null-C-3",8), rep("R-Transgenic-C-3",8), rep("R-Null-S-3",8),rep("R-Transgenic-S-3",6),rep("R-Null-C-51",4), rep("R-Null-S-51",4), rep("R-Transgenic-C-51",4), rep("R-Transgenic-S-51",4)))
  }
dev.off()

#heatmap plots of module expression
#create a heatmap plots of module expressions. This may help identify modules that are "held together" by
#spurious correlations caused by outlying arrays.       
pdf(paste(location, tissue, "/modularexpression_", tissue, ".pdf", sep=""), height = 700, width = 2000)
    par(mfrow=c(length(unique(dynamicColors)),1), mar=c(0.1, 0.2, 0.4, 0.1))
    for (whichmodule in unique(dynamicColors)){
      which.module=whichmodule;
      plotMat(t(scale(exprDat[,dynamicColors==which.module ]) ),nrgcols=30,rlabels=T, clabels=T,rcols=which.module, title=which.module) 
    }
dev.off()

# The following data frame contains the kME values corresponding to each module
MM <- as.data.frame(cor(exprDat, MEs, use = "p")); #Module membership == eigengene based intramodular connectivity(kME)
#Intramodular connectivity
#adj1 = abs(cor(exprDat, use="p"))^softPower
#For inital modules
Alldegrees <-  intramodularConnectivity(adj, dynamicColors)

#Module membership value for each gene for each module
datKME <- signedKME(exprDat, MEs, outputColumnName="MM.")

#Finding genes with high intramodular connectivity in modules
FilterGenes_wgcna <- abs(datKME$MM.yellow)>.9 #abs() is for the absolute value
table(FilterGenes_wgcna)
dimnames(data.frame(exprDat))[[2]][FilterGenes_wgcna]

#Fishing out specific genes from the modules
module_colors <- setdiff(unique(dynamicColors), "grey")
#genes         <- read.csv("/mnt/bioinf-4/shani/barley_RNASeq/salt_genes/Root_Beecher_Specific_GeneswithAThomologs_up.tab", header=F, sep =" ")
genes         <- "AT2G25090"
for (gene in genes){
  for (color in module_colors){
    module   <- GeneNames[which(dynamicColors==color)]
    only     <- intersect(gene,module)
    if(length(only)>=1){
    print(paste(color, only, sep=" : "))}
  }
}
@

<<modulemerging>>=
#order the exprDat (barley data)
#exprDat <- exprDat[order(sub('.*\\B','',row.names(exprDat))),]
# Recalculate MEs with color labels
MEs0 <- moduleEigengenes(exprDat, dynamicColors)$eigengenes
MEs <- orderMEs(MEs0)
       
#Merging closer modules       
# Calculate dissimilarity of module eigengenes
MEDiss <- 1-cor(MEs);
# Cluster module eigengenes
METree <- hclust(as.dist(MEDiss), method = "average");
# Plot the result
#sizeGrWindow(7, 6)
pdf(paste(location, tissue, "/MEtree_", tissue, ".pdf", sep=""), height = 100, width = 100)
plot(METree, main = "Clustering of module eigengenes",xlab = "", sub = "")
MEDissThres <- 0.3
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
dev.off()
# Call an automatic merging function
merge <- mergeCloseModules(exprDat, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors <- merge$colors;
# Eigengenes of the new merged modules:
mergedMEs    <- merge$newMEs;
#redrawing the gene dendogram
pdf(paste(location, tissue, "/mergedgenetree_", tissue, ".pdf", sep=""),width = 50, height = 20)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
					c("Dynamic Tree Cut", "Merged dynamic"),
					dendroLabels = FALSE, hang = 0.03,
					addGuide = TRUE, guideHang = 0.05); dev.off()
					 
#How related are the merged eigengenes now?
pdf(paste(location,tissue, "/merged_modulerelatedness_" , tissue, ".pdf",sep=""), height=10, width=30);
plotEigengeneNetworks(mergedMEs, "", marDendro = c(1,4,1,2), marHeatmap = c(3,4,1,2)); dev.off()
#sizeGrWindow(8,9)
pdf(paste(location,tissue, "/merged_moduleeigengenes_" , tissue, ".pdf",sep=""), height=15, width=40)
plotMEpairs(mergedMEs)
dev.off()

# The following data frame contains the kME values corresponding to each module
MM <- as.data.frame(cor(exprDat, mergedMEs, use = "p")); #Module membership == eigengene based intramodular connectivity(kME)

#Intramodular connectivity
#adj1 = abs(cor(exprDat, use="p"))^softPower
#For merged modules
Alldegrees1 <-  intramodularConnectivity(adj, mergedColors)
#ConnectivityMeasures = intramodularConnectivity(adj,colors=dynamicColors)
#kIM = intramodularConnectivity.fromExpr(exprDat[, restGenes], colors=dynamicColors[restGenes], scaleByMax=TRUE)

#Relationship between intramodular conenctivity and gene significance
#colorlevels <- unique(mergedColors)
#colorlevels=levels(factor(dynamicColors))
#png(paste("wgcna/",location,"/IntrmodularKplot.png", sep=""),width = 750, height = 800)
#sizeGrWindow(9,6)
#par(mfrow=c(2,as.integer(0.5+length(colorlevels)/2)))
#par(mfrow=c(4,3),mar=c(5, 4, 4, 2) + 0.1)
#for (i in c(1:length(colorlevels) ) ) {
#  whichmodule=colorlevels[[i]];
#  restrict1=(mergedColors==whichmodule);
#  verboseScatterplot(Alldegrees1$kWithin[restrict1], 
#                     GeneSignificance[restrict1],col=mergedColors[restrict1],
#                     main =paste("set I,", whichmodule),
#                     ylab="Gene Significance",xlab="Intramodular k", abline=TRUE) 
#can be kIM#KWithin /ConnectivityMeasures$kWithin as well
#}
#dev.off()
#Module membership value for each gene for each module
datKME_merged <- signedKME(exprDat, mergedMEs, outputColumnName="MM.")

#Extract modules
module_colors <- setdiff(unique(mergedColors), "grey")
for (color in module_colors){
    module <- GeneNames[which(mergedColors==color)]
    write.table(module, paste(location, tissue,"/merged_module_",color, tissue, ".txt",sep=""), sep="\t", row.names=FALSE, col.names=FALSE,quote=FALSE)
}

#Fishing out specific genes from the modules (genotype specific genes)

gene_Fls      <- list.files(path="/mnt/bioinf-4/shani/barley_RNASeq/DEanalysis/genotype_specific/salt_responsive_annotated/", pattern="*.tab", full=TRUE)
#loop through the files in geneFls
for (i in 1:length(gene_Fls)){
	genes         <- read.csv(gene_Fls[i],  header=F, sep ="\t")
	if (length(genes)>=1) {
		genes 		  <- genes[,2]
		result        <- data.frame(Result=vector(),stringsAsFactors=FALSE)
		for (gene in genes){
			module_colors <- setdiff(unique(mergedColors), "grey")
			for (color in module_colors){
					module   <- GeneNames[which(mergedColors==color)]
					only     <- intersect(gene,module)
				if(length(only)>=1){
					result <- rbind(result, paste(color, only, sep=" : "))
				}
			}
		}
		write.csv(result, paste("/mnt/bioinf-4/shani/barley_RNASeq/DEanalysis/wgcna/modulesofGSgenes/", sub("\\..*", "",  basename(geneFls[i])), "_gsSRGs.tab", sep=""), row.names = FALSE, quote=FALSE)
	}
}

genes         <- read.csv("HvHKTaccessions.txt", header=F, sep =",")
#genes        <- read.csv("/mnt/bioinf-4/shani/barley_RNASeq/DEanalysis/genotype_specific/salt_responsive_annotated/Root_Alex_up_salt_responsive_annotated.tab", header=F, sep ="\t")
genes         <- genes[,1]
specialcolor = "orangered1"
c1 <- 0
for (gene in genes){
  for (color in module_colors){
    module   <- GeneNames[which(mergedColors==color)]
    only     <- intersect(gene,module)
    if(length(only)>=1){
	print(paste(color, only, sep=" : "))
	if (color==specialcolor){c1 <- c1+1}
		}
	 }
	}
	print(paste(c1, length(genes), sep="/"))
	
#Look at expression patterns of these genes, as they are clustered
module.order <- unlist(tapply(1:ncol(exprDat),as.factor(mergedColors),I))
m            <- t(t(exprDat[,module.order])/apply(exprDat[,module.order],2,max))

pdf(paste(location, tissue,"/merged_heatmap_modules_", tissue, ".pdf", sep=""),width = 30, height = 42)
par(mfrow=c(1,1)); par(mar=c(10,8,4,12))
heatmap(t(m),zlim=c(0,1),col=heat.colors(256),Rowv=NA,Colv=NA,labRow=NA,cellheight=9.4, scale="none",RowSideColors=mergedColors[module.order])
dev.off()

#Displaying module heatmaps and eigengenes to see the relationship between eachother
pdf(paste(location, tissue,"/mergedmodules2_", tissue, ".pdf", sep=""), onefile=T, height = 12, width = 30)
for (whichmodule in unique(mergedColors)){
  whichmodule <- whichmodule
  ME<- mergedMEs[, paste("ME", whichmodule, sep='')]
  #sizeGrWindow(8,7);
    par(mfrow=c(2,1), mar=c(0.3,15,10,5))
    plotMat(t(scale(exprDat[, mergedColors==whichmodule]) ), nrgcols=120, rcols=whichmodule)
    title(whichmodule, cex.main = 2.9, line = 2)
    par(mar=c(20,10,0.5,2)); par(las=2)
    barplot(ME, col=whichmodule, main='', offset = 0, width=1.8, space=0.1, cex.main=2, cex.axis = 1, cex.lab = 2, cex.names = 2, mgp=c(5,1,.5), ylab="Eigengene expression", axisnames=T, names.arg = c(rep("R-Null-C-3",8), rep("R-Transgenic-C-3",8), rep("R-Null-S-3",8),rep("R-Transgenic-S-3",6),rep("R-Null-C-51",4), rep("R-Null-S-51",4), rep("R-Transgenic-C-51",4), rep("R-Transgenic-S-51",4)))
  
}; dev.off()

#Finding genes with high intramodular connectivity in modules
#FilterGenes_wgcna <- abs(datKME_merged$MM.green)>.9 #abs() is for the absolute value
#table(FilterGenes_wgcna)
#dimnames(data.frame(exprDat))[[2]][FilterGenes_wgcna]
@
\end{document}